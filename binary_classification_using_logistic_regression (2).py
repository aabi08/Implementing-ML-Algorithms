# -*- coding: utf-8 -*-
"""Binary classification using logistic regression

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TK9Iey5E9M5B50Zsmxsd3shy2CRvA7Xa
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


df= pd.read_csv('/content/train.csv')

df.shape
df= df.drop(columns='ID')
df.head()
col= df.columns

for label in col:
 plt.hist(df[df['Target']==0][label], color='blue', alpha=0.7, density= True)
 plt.hist(df[df['Target']==1][label], color='red', alpha=0.7, density= True)
 plt.show()

k= df['Target']
df= df.drop(columns='Target')

cols= list(df.columns)

for c in cols:
  avg= df[c].mean()
  df[c].fillna(value=avg, inplace=True)

df.describe()

for c in cols:
  mean= df[c].mean();
  sd= df[c].std();
  df[c]= (df[c]-mean)/sd;




x_train,x_test= np.split( df.sample(frac=1,), [int(0.8*len(df))] )
y_train, y_test= np.split( k.sample(frac=1), [int(0.8*len(k))])







x_train= x_train.values
x_test= x_test.values
y_train= y_train.values
y_test= y_test.values

x_train= x_train.T
y_train= y_train.reshape(1, x_train.shape[1])

x_test= x_test.T
y_test= y_test.reshape(1,x_test.shape[1])

# print(x_train.shape)
# print(x_test.shape)
# print(y_train.shape)
# print(y_test.shape)

def sigmoid(x):
  return 1/(1+np.exp(-x))

def LR_model(X,Y,alpha,iterations):  #alpha= learning rate ,related to how fast gradient descent reaches minimum
  m= x_train.shape[1]
  n= x_train.shape[0]

  w= np.zeros((n,1))
  b=0
  # cost_value=[]  # for keeping track of cost function
  for i in range(iterations):
    P= np.dot(w.T,X) + b    # y= w^Tx +b (linear relation)
    A=[]   #  A lies between 0 and 1
    for x in P:
      A.append(sigmoid(x))

    # cost= (-1/m)*np.sum(Y*np.log(A) + (1-Y)*np.log(1-A)) #cost function


    dw= (1/m)*np.dot(A-Y, X.T)
    db= (1/m)*np.sum(A-Y)

    w= w - alpha*(dw.T)
    b= b- alpha*db

    # # cost_value.append(cost)
    # if(i%(iterations/10)==0):
    #   print("cost after", i , "iterations =", cost)

  return w,b,A,P

iterations= 10000
alpha= 0.015

W,B,A,P= LR_model(x_train, y_train, alpha=0.005, iterations=10000)

print(P)
print(A)

for x in A:
  x= x>0.5

A= np.array(A, dtype='int64')
acc =  (1- np.sum(np.absolute(A-y_train))/y_train.shape[1])*100

print(acc)